# DOCS/ARCHITECTURE/adr-023-vector-store-service-responsibilities.md

---

# ADR-023: Vector Store Service Responsibilities

## Status

Proposed

## Context

The **Vector Store Service (VSS)** is a core microservice responsible for **storing, retrieving, and managing vector embeddings** for downstream search and retrieval tasks. Embeddings are generated by upstream ingestion services or external providers and must be persisted reliably with metadata for future similarity searches and traceability.

Prior solutions (e.g., storing vectors inline with ingestion services) introduced **tight coupling** and made scaling search operations cumbersome. This ADR defines a dedicated service with clear responsibilities.

---

## Decision

The **Vector Store Service** will be **the authoritative store of vectors** and will expose a REST API for ingestion, search, and deletion.

### Core Responsibilities

1. **Vector Persistence**

   * Accept vectors with associated metadata in **batch inserts**.
   * Persist vectors in **PostgreSQL** using the `pgvector` extension.
   * Track provenance and chunk details: `ingestion_id`, `chunk_id`, `chunk_index`, `chunk_strategy`, `chunk_text`, `source_metadata`, and `provider`.

2. **Similarity Search**

   * Provide a `k`-nearest-neighbor search endpoint.
   * Use PostgreSQL `<->` operator via `pgvector` for efficient vector similarity retrieval.
   * Return both the vector and associated metadata for downstream consumption.

3. **Vector Deletion**

   * Delete all vectors associated with a given `ingestion_id`.
   * Support cleaning up data after ingestion pipelines or retention policies.

4. **Ingestion Request Tracking**

   * Provide minimal ingestion lifecycle tracking:

     * Register ingestion requests (`pending → running → completed/failed`).
     * Store metadata, timestamps, and source type.
   * This supports auditability and debugging.

5. **Schema Validation**

   * Validate the existence and correctness of the `vectors` table at startup.
   * Fail-fast if schema is missing or incompatible.

6. **Stateless Service Design**

   * The service is **stateless** aside from the database.
   * Supports horizontal scaling behind a load balancer.

---

## Consequences

* **Separation of Concerns**: Embedding generation, chunking, and vector storage are decoupled.
* **Scalability**: Vector search and persistence can be scaled independently of ingestion.
* **Traceability**: Metadata allows auditing vector origins and chunking strategies.
* **Reliability**: Schema validation ensures service won't run against an incompatible database.
* **Extensibility**: Future vector store implementations (e.g., FAISS, Milvus) can inherit from `VectorStore` base class without breaking API contracts.

---

## Implementation Notes

* Vector store implementation: `PgVectorStore` (PostgreSQL + pgvector).
* API endpoints:

  * `POST /v1/vectors/batch` → batch insert
  * `POST /v1/vectors/search` → similarity search
  * `DELETE /v1/vectors/by-ingestion/{ingestion_id}` → delete by ingestion
  * `POST /v1/ingestions` → register ingestion request
* Uses **FastAPI** with dependency injection for vector store instance.
* Environment variables configure the database URL, vector dimension, and embedding provider.

---

This ADR establishes **VSS as the single source of truth for embeddings**, ensuring clean separation from ingestion and chunking responsibilities.

---

